<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Richie</title>
  
  
  <link href="https://qiaimhigh.gothub.io/atom.xml" rel="self"/>
  
  <link href="https://qiaimhigh.gothub.io/"/>
  <updated>2022-06-01T12:49:08.560Z</updated>
  <id>https://qiaimhigh.gothub.io/</id>
  
  <author>
    <name>Richie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>身份认证机制</title>
    <link href="https://qiaimhigh.gothub.io/2022/06/01/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://qiaimhigh.gothub.io/2022/06/01/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</id>
    <published>2022-06-01T12:48:38.612Z</published>
    <updated>2022-06-01T12:49:08.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、两种主流的Web开发模式"><a href="#一、两种主流的Web开发模式" class="headerlink" title="一、两种主流的Web开发模式"></a>一、两种主流的Web开发模式</h1><p>在我们了解两种主流的认证机制之前，我们先来了解一下目前主流的两种Web开发模式。</p><h3 id="基于服务端渲染的传统Web开发模式"><a href="#基于服务端渲染的传统Web开发模式" class="headerlink" title="基于服务端渲染的传统Web开发模式"></a>基于服务端渲染的传统Web开发模式</h3><p><code>服务端渲染</code>：服务器发送给客户端的 HTML 页面，<strong>是在服务器通过字符串的拼接，动态生成的</strong>。客户端只负责解析 HTML 。</p><p><img src="https://img-blog.csdnimg.cn/db2a88caf61c4258b7f4d0dcf3e3aeee.png" alt="在这里插入图片描述"></p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>前端耗时少。因为在服务端动态生成HTML内容，浏览器只需要直接渲染页面就好了。尤其是移动端，更省电。</li><li>有利于SEO<strong>（也称为搜索引擎优化）</strong>。因为服务器响应的是完整的HTML页面内容，所以爬虫更容易爬取获取信息，更利于SEO。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><code>占用服务器端资源</code>。即服务器端完成 HTML 页面内容的拼接，<strong>如果请求较多，会对服务器造成一定的访问压力。</strong></li><li><code>不利于前后端分离，开发效率低</code>。使用服务器端渲染，则<strong>无法进行分工合作</strong>，尤其对于<strong>前端复杂度高的项目，不利于项目高效开发</strong></li></ul><h3 id="基于前后端分离的新型Web开发模式"><a href="#基于前后端分离的新型Web开发模式" class="headerlink" title="基于前后端分离的新型Web开发模式"></a>基于前后端分离的新型Web开发模式</h3><p><code>前后端分离</code>：后端只负责<strong>提供 API 接口</strong>（处理、存储数据），前端使用 <strong>Ajax 调用接口</strong>（显示数据）。前端和后端开发人员通过 <code>接口</code> 进行数据的交换。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。</li><li>用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。</li><li>减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 SSR 技术能够很好的解决 SEO 问题！）</li></ul><h3 id="如何选择开发模式"><a href="#如何选择开发模式" class="headerlink" title="如何选择开发模式"></a>如何选择开发模式</h3><ul><li><p>比如企业级网站，主要功能是<strong>展示而没有复杂的交互，并且需要良好的 SEO</strong>，则这时我们就需要使用<code>服务器端渲染</code>；</p></li><li><p>而类似<strong>后台管理项目，交互性比较强，不需要考虑 SEO</strong>，那么就可以使用<code>前后端分离</code>的开发模式。</p><p><strong><code>注意</code><strong>：具体使用何种开发模式</strong>并不是绝对的</strong>，<strong>为了同时兼顾了首页的渲染速度和前后端分离的开发效率</strong>，一些网站采用了<code>首屏服务器端渲染 + 其他页面前后端分离</code>的开发模式。</p></li></ul><h1 id="二、什么是身份认证机制"><a href="#二、什么是身份认证机制" class="headerlink" title="二、什么是身份认证机制"></a>二、什么是身份认证机制</h1><p>1、<strong>身份认证</strong>（Authentication）：又称“<code>身份验证</code>”、“<code>鉴权</code>”，是指<strong>通过一定的手段，完成对用户身份的确认。</strong> 在 Web 开发中，也涉及到用户身份的认证，例如：<strong>各大网站的手机验证码登录、邮箱密码登录、二维码登录等。</strong></p><p>2、目的：为了确认当前所声称为某种身份的用户，确实是所声称的用户</p><p>3、目前主流的身份认证有session认证机制和JWT认证机制，那么如何选择身份认证的方式</p><ul><li><code>服务端渲染</code>推荐使用 <strong>Session 认证机制</strong></li><li><code>前后端分离</code>推荐使用 <strong>JWT 认证机制</strong></li></ul><h1 id="三、Session认证机制"><a href="#三、Session认证机制" class="headerlink" title="三、Session认证机制"></a>三、Session认证机制</h1><p>1.HTTP协议的无状态性：指的是客户端的每次 HTTP 请求都是 <strong>独立的</strong>，<strong>连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态</strong>。</p><p>2.为了解决 HTTP 无状态的限制，我们可以使用 <code>Cookie</code>。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>1.<code>Cookie</code> 是<strong>存储在用户浏览器中的一段不超过 4 KB 的字符串</strong>。它由一个<code>名称</code>（Name）、一个<code>值</code>（Value）和其它几个用于控制 Cookie <code>有效期</code>、<code>安全性</code>、<code>使用范围</code>的可选属性组成。</p><p><img src="https://img-blog.csdnimg.cn/e56d3b17a73e43fe864fc7340f0957ed.png" alt="请添加图片描述"></p><ol start="2"><li><p>不同域名下的 Cookie <strong>各自独立</strong>，每当客户端发起请求时，会<strong>自动</strong>把<code>当前域名下所有未过期的 Cookie</code>一同发送到服务器。</p></li><li><p>Cookie的特性</p><p>自动发送</p><p>域名独立</p><p>具有过期时限</p><p>4kb限制</p></li></ol><p>4.客户端第一次请求服务器的时候，<strong>服务器</strong>通过响应头的形式，向<strong>客户端</strong>发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中。 之后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。</p><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/98fc3d3e43484cbcacf281e7b603a87b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29uY2lzaW9uLg==,size_20,color_FFFFFF,t_70,g_se,x_16">https://img-blog.csdnimg.cn/98fc3d3e43484cbcacf281e7b603a87b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29uY2lzaW9uLg==,size_20,color_FFFFFF,t_70,g_se,x_16</a></p><p>5.Cookie的不安全性：*<em>由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全性。并且更具浏览器所提供的接口，可以伪造一些数据，因此不具有安全性。所以切记不要将用户的重要信息</em>（如：用户密码、账号信息等）通过Cookie发送给浏览器</p><p><img src="https://img-blog.csdnimg.cn/8b08ff7579a0418d9f3cc0801f2fd53a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29uY2lzaW9uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>6.<strong>服务器可通过认证Cookie的形式</strong>去提高身份认证的安全性。比如：为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以 <strong><code>在收银机上进行刷卡认证</code></strong> 。只有收银机确认存在的会员卡，才能被正常使用</p><p><img src="https://img-blog.csdnimg.cn/412844d5525147f89c44ee8998be436f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29uY2lzaW9uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>注意</strong>：这种“<strong>会员卡 + 刷卡认证</strong>”的设计理念，就是 <code>Session 认证机制</code>的精髓。</p><h3 id="Session工作机制"><a href="#Session工作机制" class="headerlink" title="Session工作机制"></a>Session工作机制</h3><p><img src="https://img-blog.csdnimg.cn/1f62ddf382d946bfa11480afdce88d3a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29uY2lzaW9uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="在-Express-中使用-Session-认证"><a href="#在-Express-中使用-Session-认证" class="headerlink" title="在 Express 中使用 Session 认证"></a>在 <a href="https://so.csdn.net/so/search?q=Express&spm=1001.2101.3001.7020">Express</a> 中使用 Session 认证</h2><p>1.安装express-session</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express-session</span><br></pre></td></tr></table></figure><p>2.创建session中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>导入session</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="number">2.</span>创建seesion中间件</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&quot;session(&#123;</span></span><br><span class="line"><span class="string">secret: &#x27;&#x27;, // 定义密钥：可以是任意字符串</span></span><br><span class="line"><span class="string">         resave: false, //固定写法</span></span><br><span class="line"><span class="string">         saveUninitialized: true //固定写法</span></span><br><span class="line"><span class="string">     &#125;)&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.通过<code>req.session</code>来访问<code>session</code>对象，从而储存用户的关键信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试登录接口</span></span><br><span class="line"><span class="comment">// 在设置express-session中间件之后，req上就会多出一个session的属性，以便于我们操作</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(req.seeesion);</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">body</span>.<span class="property">username</span> !== <span class="string">&#x27;Richie&#x27;</span> &amp;&amp; req.<span class="property">body</span>.<span class="property">password</span> !== <span class="string">&#x27;123456&#x27;</span>)&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">1</span>,<span class="attr">msg</span>:<span class="string">&#x27;登陆失败&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// user、islogin是自己定义的存储属性</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="property">user</span> = req.<span class="property">body</span>; <span class="comment">// 用户的信息</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="property">islogin</span> = <span class="literal">true</span>; <span class="comment">// 用户的登录状态</span></span><br><span class="line">    </span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">message</span>: <span class="string">&#x27;登录成功&#x27;</span> &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.可以通过<code>req.session</code>对象获取之前存储的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户姓名的接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/username&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!req.<span class="property">session</span>.<span class="property">isLogin</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">1</span>,<span class="attr">msg</span>: <span class="string">&#x27;用户未登录&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;查询成功&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">username</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.调用 <code>req.session.destroy()</code> 函数，即可<strong>清空</strong>服务器保存的 session 信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 退出登录的接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/logout&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清空 Session 信息</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>()</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;退出登录成功&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>6.完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入session模块</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line"><span class="comment">// 配置session</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;node five&#x27;</span>,</span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>, <span class="comment">//固定写法</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">true</span> <span class="comment">// 固定写法</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// 测试登录接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">body</span>.<span class="property">username</span> !== <span class="string">&#x27;Richie&#x27;</span> &amp;&amp; req.<span class="property">body</span>.<span class="property">password</span> !== <span class="string">&#x27;123456&#x27;</span>)&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">1</span>,<span class="attr">msg</span>:<span class="string">&#x27;登陆失败&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">user</span> = req.<span class="property">body</span>;</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">isLogin</span> = <span class="literal">true</span>; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 获取用户姓名的接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/username&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!req.<span class="property">session</span>.<span class="property">isLogin</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">1</span>,<span class="attr">msg</span>: <span class="string">&#x27;用户未登录&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;查询成功&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">username</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 退出登录接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/exit&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!req.<span class="property">session</span>.<span class="property">isLogin</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">1</span>,<span class="attr">msg</span>: <span class="string">&#x27;用户未登录&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空session信息</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>()</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;退出登录成功&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>7.Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</p><ul><li>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</li><li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</li></ul><h1 id="四、JWT认证机制"><a href="#四、JWT认证机制" class="headerlink" title="四、JWT认证机制"></a>四、JWT认证机制</h1><h4 id="1、JWT（-JSON-Web-Token）认证机制-目前最流行的跨域解决方案"><a href="#1、JWT（-JSON-Web-Token）认证机制-目前最流行的跨域解决方案" class="headerlink" title="1、JWT（ JSON Web Token）认证机制*,目前最流行的跨域解决方案*"></a>1、JWT（ JSON Web Token）认证机制*,目前最流行的跨域解决方案*</h4><p>JWT通常由三部分组成:Header(头部)、payLoad(有效荷载)、Signature(签名)三者之间用 . 号分隔开</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OPJHgINv-1654087076049)(C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20220530180719900.png)]</p><p><img src="https://img-blog.csdnimg.cn/0c4738c3b70a471381dbef9a107672b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29uY2lzaW9uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>用户的信息通过 <code>Token</code> 字符串的形式，<strong>保存在客户端浏览器中</strong>。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p><img src="https://img-blog.csdnimg.cn/a8beeaa10ac34190a9d8f44dad5aad43.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29uY2lzaW9uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage中。此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt;</span><br></pre></td></tr></table></figure><h3 id="在express中使用JWT"><a href="#在express中使用JWT" class="headerlink" title="在express中使用JWT"></a>在express中使用JWT</h3><p>1.安装<code>JWT</code>需要使用的两个包：<code>jsonwebtoken</code> 和 <code>express-jwt</code> ,其中<code>jsonwebtoken</code>是用来生成<code>JWT</code>字符串的，<code>express-jwt</code>是用来解析字符串还原成<code>JSON</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i jsonwebtoken express-jwt</span><br></pre></td></tr></table></figure><p>2.导入<code>JWT</code>相关的包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> expressJWT = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.定义<code>serect</code>密钥</p><p>为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个<strong>用于加密和解密</strong>的 <code>secret</code> 密钥，密钥设置的越复杂越好：</p><ul><li><em>当生成 <code>JWT</code>字符串的时候，需要使用secret密钥对用户信息进行加密，最终得到加密好的<code>JWT</code>字符串</em></li><li><em>当把<code>JWT</code>字符串解析还原成<code>JSON</code>对象的时候，需要使用secret密钥进行加密</em></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// secret密钥的本质：就是一个字符串</span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;Richie Node five ^_^_^_^&#x27;</span></span><br></pre></td></tr></table></figure><p>4.注册中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用app.use()来注册中间件</span></span><br><span class="line"><span class="comment">// expressJWT(&#123; secret: secretKey, algorithms: [&#x27;HS256&#x27;] &#125;)就是来解析Token的中间件</span></span><br><span class="line"><span class="comment">// .unless(&#123; path: [/^\/api\//] &#125;)用来指定哪些接口不需要访问权限，这里是凡是以/api为开头的接口都不需要访问权限</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123; <span class="attr">secret</span>: secretKey, <span class="attr">algorithms</span>: [<span class="string">&#x27;HS256&#x27;</span>] &#125;).<span class="title function_">unless</span>(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>] &#125;))</span><br></pre></td></tr></table></figure><p>5.在登录成功后生成 JWT 字符串</p><p>调用 <code>jsonwebtoken</code> 包提供的 <code>sign()</code> 方法，<strong>将用户的信息加密成 JWT 字符串，响应给客户端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    <span class="keyword">const</span> userInf = req.<span class="property">body</span>;</span><br><span class="line">    <span class="comment">// 登陆失败</span></span><br><span class="line">    <span class="keyword">if</span>(userInf.<span class="property">username</span>!==<span class="string">&#x27;admin&#x27;</span>&amp;&amp;userInf.<span class="property">password</span>!==<span class="string">&#x27;000000&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">400</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;登陆失败&#x27;</span></span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//登陆成功之后：调用jwt.sign(参1，2，3)方法生成JWT字符串。并且通过 token属性发送给客户端</span></span><br><span class="line">        <span class="comment">//参数1：用户的信息对象  2：加密的密钥 3：配置对象，可以配置当前的token的有效期</span></span><br><span class="line">        <span class="comment">// 千万不要把密码加载到 JSON 字符串中，不然存在泄露的风险</span></span><br><span class="line">    <span class="keyword">const</span> tokenStr = jwt.<span class="title function_">sign</span>(&#123;<span class="attr">username</span>:userInf.<span class="property">username</span>&#125;,secretKey,&#123;<span class="attr">expiresIn</span>:<span class="string">&#x27;3000s&#x27;</span>&#125;)</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;登陆成功！&#x27;</span>,</span><br><span class="line">        <span class="attr">token</span>: tokenStr <span class="comment">// 要给客户端的 token 字符串</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f9ceedf08f384fbd9e2e6530c7a346c1.png" alt="请添加图片描述"></p><p>6.使用 <code>req.user</code> 获取用户信息</p><p>当 <code>express-jwt</code> 这个中间件配置成功之后，即可在那些有权限的接口中，使用 <code>req.user</code> 对象，来访问从 JWT 字符串中解析出来的用户信息了，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个有权限的API接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin/getinfo&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">user</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>:<span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;获取用户信息成功&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:req.<span class="property">user</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当不在请求头中传入token时：</p><p><img src="https://img-blog.csdnimg.cn/366454356ff54fb99a61b6d5e507741a.png" alt="请添加图片描述"></p><p>当传入正确的token时：</p><p><img src="https://img-blog.csdnimg.cn/657f0245ee1d4be0ac4ab3d7599d8a3b.png" alt="请添加图片描述"></p><p>7.捕获解析 JWT 失败后产生的错误</p><p>当使用 <code>express-jwt</code> 解析 Token 字符串时，如果客户端发送过来的 Token 字符串<strong>过期或不合法</strong>，会产生一个解析失败的错误，影响项目的正常运行。我们可以通过 Express 的<code>错误中间件</code>，捕获这个错误并进行相关的处理，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这次错误是由 token 解析失败导致的</span></span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">name</span> === <span class="string">&#x27;UnauthorizedError&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">401</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;无效的token&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">send</span>(&#123;![请添加图片描述](<span class="attr">https</span>:<span class="comment">//img-blog.csdnimg.cn/cb8c3e483f684c0888db519e4a2eb516.png)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">status</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;未知的错误&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8.完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 允许跨域资源共享</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入与JWT相关的两个包，jsonwebtoken express-jwt</span></span><br><span class="line"><span class="comment">// 当express-jwt这个中间件配置成功之后，即可在那些有权限的接口中，使用req.user对象，来访问从JWT字符串中解析出来的用户信息</span></span><br><span class="line"><span class="keyword">const</span> expressJWT = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>); <span class="comment">// 解析还原JSON对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>); <span class="comment">// 生成JWT字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;Richie Node five&#x27;</span>;</span><br><span class="line"><span class="comment">// 使用app.use()来注册中间件</span></span><br><span class="line"><span class="comment">// expressJWT(&#123; secret: secretKey, algorithms: [&#x27;HS256&#x27;] &#125;)就是来解析Token的中间件</span></span><br><span class="line"><span class="comment">// .unless(&#123; path: [/^\/api\//] &#125;)用来指定哪些接口不需要访问权限，这里是凡是以/api为开头的接口都不需要访问权限</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123; <span class="attr">secret</span>: secretKey, <span class="attr">algorithms</span>: [<span class="string">&#x27;HS256&#x27;</span>] &#125;).<span class="title function_">unless</span>(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>] &#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    <span class="keyword">const</span> userInf = req.<span class="property">body</span>;</span><br><span class="line">    <span class="comment">// 登陆失败</span></span><br><span class="line">    <span class="keyword">if</span>(userInf.<span class="property">username</span>!==<span class="string">&#x27;admin&#x27;</span>&amp;&amp;userInf.<span class="property">password</span>!==<span class="string">&#x27;000000&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">400</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;登陆失败&#x27;</span></span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//登陆成功之后：调用jwt.sign(参1，2，3)方法生成JWT字符串。并且通过 token属性发送给客户端</span></span><br><span class="line">        <span class="comment">//参数1：用户的信息对象  2：加密的密钥 3：配置对象，可以配置当前的token的有效期</span></span><br><span class="line">        <span class="comment">// 千万不要把密码加载到 JSON 字符串中，不然存在泄露的风险</span></span><br><span class="line">    <span class="keyword">const</span> tokenStr = jwt.<span class="title function_">sign</span>(&#123;<span class="attr">username</span>:userInf.<span class="property">username</span>&#125;,secretKey,&#123;<span class="attr">expiresIn</span>:<span class="string">&#x27;3000s&#x27;</span>&#125;)</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;登陆成功！&#x27;</span>,</span><br><span class="line">        <span class="attr">token</span>: tokenStr <span class="comment">// 要给客户端的 token 字符串</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个有权限的API接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin/getinfo&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    请添加图片描述thorizedError<span class="string">&#x27;) return res.send(&#x27;</span>登陆过期请重新登录！<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">    res.send(&#123;</span></span><br><span class="line"><span class="string">        status:500,</span></span><br><span class="line"><span class="string">        message: &#x27;</span>未知错误<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">app.listen(80,()=&gt;&#123;</span></span><br><span class="line"><span class="string">    console.log(&#x27;</span><span class="attr">http</span>:<span class="comment">//127.0.0.1&#x27;);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、两种主流的Web开发模式&quot;&gt;&lt;a href=&quot;#一、两种主流的Web开发模式&quot; class=&quot;headerlink&quot; title=&quot;一、两种主流的Web开发模式&quot;&gt;&lt;/a&gt;一、两种主流的Web开发模式&lt;/h1&gt;&lt;p&gt;在我们了解两种主流的认证机制之前，我们先来了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>npm命令</title>
    <link href="https://qiaimhigh.gothub.io/2022/05/30/npm/"/>
    <id>https://qiaimhigh.gothub.io/2022/05/30/npm/</id>
    <published>2022-05-30T09:03:07.636Z</published>
    <updated>2022-06-01T12:47:53.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm介绍"><a href="#npm介绍" class="headerlink" title="npm介绍"></a>npm介绍</h1><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>前言：我们在日常使用npm下载包的时候，可能就是在网上搜一下下载教程，然后按照那些文章中所介绍的命令去下载。我相信在执行那些命令的时候，大部分人都不知道，到底为什么要这样子写，只知道使用这些命令可以下载到自己想使用的包。如果你想了解那些命令是什么意思的话，那么希望这篇文章可以带给你一些收获。</p><h3 id="认识npm"><a href="#认识npm" class="headerlink" title="认识npm"></a>认识npm</h3><p>npm是一个NodeJS包管理器和分发工具，当我们需要使用npm命令的时候，我们需要安装一下Node.js，不然我们就不能使用npm命令。</p><p>Node.js下载网址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>我们会看到如下界面：</p><p><img src="https://img-blog.csdnimg.cn/f41ba9cb6aab4a46b15a0b3620a6a940.png" alt="请添加图片描述"></p><p>我们会看到有一个LTS版本和一个Current版本，那么我们该如何选择呢？</p><p>我来先给咱们解释一下：其实从版本号就可以看出一个新一个老。Current就是当前最新的版本，最新的功能特性都在这里面了。就是拿来给你试用测试的，要是大家都用得还好，功能稳定了，就发布到LTS版本。所以LTS就是稳定版。</p><p>在这里我建议大家选择LTS版本的，它不仅可以满足我们的日常学习，而且主要的是它用着稳定，简直香喷喷。</p><p>当我们安装好Node之后，因为npm是Node自带的一个包管理器，所以所我们不需要安装，就可以直接使用npm去运行命令啦。</p><p>如果想查看自己的node的版本号，我们可以使用win+R组合键，打开cmd，在里面输入node -v就可以查看自己所安装的Node的版本号了。</p><h3 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令"></a>npm命令</h3><p>在这里我会将平时经常用到的npm命令展示给大家。</p><h5 id="1-下载包命令"><a href="#1-下载包命令" class="headerlink" title="1.下载包命令"></a>1.下载包命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 包的名称  // 也可以简写为 npm i 包的名称</span><br></pre></td></tr></table></figure><p>在这里我给大家推荐一个搜索需要使用的包的网址：<a href="https://www.npmjs.com/%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B8%8A%E9%9D%A2%EF%BC%8C%E5%8F%AA%E8%A6%81%E4%BD%A0%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%9A%84%E8%80%90%E5%BF%83%E5%8E%BB%E5%AF%BB%E6%89%BE%E6%89%80%E6%83%B3%E8%A6%81%E7%9A%84%E5%8C%85%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E5%A5%BD%E5%A4%9A%E4%BC%98%E7%A7%80%E5%A5%BD%E7%94%A8%E7%9A%84%E5%8C%85%E3%80%82%E5%90%8C%E6%97%B6%E4%B9%9F%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%B8%8B%E8%BD%BD%E8%BF%99%E5%8C%85%E7%9A%84%E5%91%BD%E4%BB%A4%E3%80%82">https://www.npmjs.com/，在这个网站上面，只要你有足够的耐心去寻找所想要的包，你可以找到好多优秀好用的包。同时也介绍了下载这包的命令。</a></p><p>但是大家在下载一些包的时候，是不是速度经常很慢很慢。这是因为npm默认的是当国外的网站上下载，所以说速度会很慢很慢。在这里我们为了提高下载的速度，可以使用国内的淘宝镜像。</p><p>那我们如果知道自己当前的默认下载路径呢，在这里我们可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry  //查询当前自己所使用的默认下载路径</span><br></pre></td></tr></table></figure><p>当我们需要切换到淘宝镜像的时候，我们可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry=https://registry.npm.taobao.org/     //切换到淘宝镜像</span><br></pre></td></tr></table></figure><p>到这里你有没有觉得上面的切换代码的方式很麻烦，需要写好长一串代码，而且一个不留神写错了，也运行不了。在这里我给大家推荐一个很好用的小工具，它可以快速的查看和切换下包的镜像源——-nrm。我们可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i nrm -g // 将nrm安装为全局可用的工具</span><br><span class="line">//查看所有的镜像源</span><br><span class="line">nrm ls</span><br><span class="line">// 切换下包的镜像</span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><p>当我们执行了<code>nrm ls</code>命令后，可以得到下图：</p><p><img src="https://img-blog.csdnimg.cn/4c845742794b4916825de63bbe869392.png" alt="请添加图片描述"></p><p>我们可以根据返回的目录，选择想要使用的镜像源，然后输入  <code>nrm use  [镜像源]</code>，就可以切换到相应的镜像源去下载了。是不是使用了这个工具之后就方便了好多。</p><p>全局包命令：</p><p>会将包安装为全局包，默认会安装在：<code>C:\Users\XXXXX\AppData\Roaming\npm\node_modules</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 包名 -g</span><br></pre></td></tr></table></figure><p>我们在平时的下载中也会经常遇到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -D    // devDependencies，开发依赖包，只在开发期间使用</span><br><span class="line">或</span><br><span class="line">npm i 包名 --save-dev    // devDependencies</span><br><span class="line">或</span><br><span class="line">npm i 包名 --save   // dependencies，核心依赖包，在开发期间和项目上线之后都会用到</span><br></pre></td></tr></table></figure><p>以上三种中，我们前两种没啥区别（<code>-D</code>就是<code>--save-dev</code>的缩写）。在我们安装包的时候，会在我们多安装的目录里面，创建一个<code>packpage.json</code>和<code>packpage-lock.json</code>的配置文件，如果没有<code>packpage.json</code>文件的话，我们可以使用<code>npm init -y</code>来创建配置文件。在<code>pack-lock.json</code>中写入了一些项目的名称、下载的包的名称、版本号、下载地址等。在<code>packpage.json</code>中，会存在<code>dependencies</code> 和<code>devDependencies</code>，当我们使用前两个命令时，下载的包名添加在<code>devDependencies</code>中，使用最后一个会添加包名到<code>dependencies</code>中。</p><p>现在我来解释以下：，一些包我们在发布后用不到它，而只是在我们开发才用到它，那么就使用<code>--save-dev</code>比较好，在<code>devDependencies</code>下创建模块。而<code>dependencies</code> 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p><h5 id="2-卸载包命令"><a href="#2-卸载包命令" class="headerlink" title="2.卸载包命令"></a>2.卸载包命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm remove 包名 [-g] 简写 npm rm 包名  </span><br><span class="line">或</span><br><span class="line">npm uninstall 包名</span><br><span class="line">需要注意的是：以上两个没啥区别  只不过是 remove 是 uninstall 的别名，它的别名还有，un、rm、unlink</span><br></pre></td></tr></table></figure><h5 id="3-更新包"><a href="#3-更新包" class="headerlink" title="3.更新包"></a>3.更新包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update 包名  简写：npm up 包名 </span><br></pre></td></tr></table></figure><h5 id="4-查看已安装的包"><a href="#4-查看已安装的包" class="headerlink" title="4.查看已安装的包"></a>4.查看已安装的包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list [-g]  简写 npm ls [-g]</span><br></pre></td></tr></table></figure><h5 id="5-清除缓存"><a href="#5-清除缓存" class="headerlink" title="5.清除缓存"></a>5.清除缓存</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><h5 id="6-npm-查看命令"><a href="#6-npm-查看命令" class="headerlink" title="6.npm 查看命令"></a>6.npm 查看命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm root  # 查看项目中模块所在的目录</span><br><span class="line">npm root -g  # 查看全局安装的模块所在目录</span><br><span class="line">npm list 或者 npm ls  # 查看本地已安装模块的清单列表</span><br><span class="line">npm view jquery dependencies  # 查看某个包对于各种包的依赖关系</span><br><span class="line">npm view jquery version  # 查看jquery最新的版本号</span><br><span class="line">npm view jquery versions  # 查看所有jquery历史版本号（很实用）</span><br><span class="line">npm view jquery  # 查看最新的jquery版本的信息</span><br><span class="line">npm info jquery  # 查看jquery的详细信息，等同于上面的npm view jquery</span><br><span class="line">npm list jquery 或 npm ls jquery  # 查看本地已安装的jquery的详细信息</span><br><span class="line">npm view jquery repository.url  # 查看jquery包的来源地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>npm 其他命令</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean  # 清除npm的缓存</span><br><span class="line">npm prune  # 清除项目中没有被使用的包</span><br><span class="line">npm outdated  # 检查模块是否已经过时</span><br><span class="line">npm repo jquery  # 会打开默认浏览器跳转到github中jquery的页面</span><br><span class="line">npm docs jquery  # 会打开默认浏览器跳转到github中jquery的<span class="variable constant_">README</span>.<span class="property">MD</span>文件信息</span><br><span class="line">npm home jquery  # 会打开默认浏览器跳转到github中jquery的主页</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><h5 id="优先从缓存缓存中加载"><a href="#优先从缓存缓存中加载" class="headerlink" title="优先从缓存缓存中加载"></a>优先从缓存缓存中加载</h5><p>模块在第一次加载后会被缓存。这也就意味了多次调用require不会导致代码被执行多次。</p><h5 id="内置模块加载的优先级最高"><a href="#内置模块加载的优先级最高" class="headerlink" title="内置模块加载的优先级最高"></a>内置模块加载的优先级最高</h5><h5 id="自定义模块："><a href="#自定义模块：" class="headerlink" title="自定义模块："></a>自定义模块：</h5><p>必须指定以 .&#x2F; 或 ..&#x2F;开头的路径标识符，若不指定，node则会将内置模块或者第三方模块进行加载。同时，如果省略文件的扩展名，则会按照顺序分别尝试加载以下文件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.按照确切的文件名进行加载</span><br><span class="line"></span><br><span class="line">2.补全.js扩展名进行加载</span><br><span class="line"></span><br><span class="line">3.不全.json扩展名进行加载</span><br><span class="line"></span><br><span class="line">4.不全.node扩展名进行加载</span><br><span class="line"></span><br><span class="line">5.加载失败，终端报错</span><br></pre></td></tr></table></figure><h5 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h5><p>如果传递给require()的模块不是一个内置模块，也不是自定义模块，则<code>Node.js</code>会从当前模块的目录开始，尝试从<code>/node_modules</code>文价夹中加载第三方模块。</p><h5 id="把目录作为加载模块"><a href="#把目录作为加载模块" class="headerlink" title="把目录作为加载模块"></a>把目录作为加载模块</h5><p>再将目录作为加载模块时，</p><p>1.首先，会查找目录下面的<code>packpage.json</code>的文件，然后在里面寻找main属性，作为require的加载的入口。</p><p>2.如果第一步查找失败，则会在文件夹下面查找<code>index.js</code> 文件</p><p>3.如以上两步全都失败，则会打印错误信息，报告，模块缺失</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;npm介绍&quot;&gt;&lt;a href=&quot;#npm介绍&quot; class=&quot;headerlink&quot; title=&quot;npm介绍&quot;&gt;&lt;/a&gt;npm介绍&lt;/h1&gt;&lt;h2 id=&quot;npm&quot;&gt;&lt;a href=&quot;#npm&quot; class=&quot;headerlink&quot; title=&quot;npm&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>this详解</title>
    <link href="https://qiaimhigh.gothub.io/2022/05/30/this%E6%8C%87%E5%90%91/"/>
    <id>https://qiaimhigh.gothub.io/2022/05/30/this%E6%8C%87%E5%90%91/</id>
    <published>2022-05-30T09:02:13.247Z</published>
    <updated>2022-06-01T12:48:01.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h1><p><font color="red">在我们研究this指向问题的时候，我们只需要知道判断this时，那个对象调用它，它就指向谁；否则就指向全局对象window，牢记这一点，我们就能很好的解决this指向问题。</font></p><h3 id="1-普通函数调用"><a href="#1-普通函数调用" class="headerlink" title="1.普通函数调用"></a>1.普通函数调用</h3><p>当普通函数调用时，this没啥特殊意外，就是指向全局对象window。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mick&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// &#x27;undefine&#x27; 相当于window.name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，因为函数f，没有人调用它所以f就会指向全局对象window，可能你会疑惑为什么this.name不会输出Mick，但是你仔细看一下，name定义的方式时let，不属于window对象,所以。（在这里我们需要注意一下，在es6中，新规定<strong>var，function声明的全局变量，仍然属于顶级对象的属性；使用let，const，class声明的全局变量不再属于顶层对象的属性</strong>）</p><h3 id="2-对象函数调用"><a href="#2-对象函数调用" class="headerlink" title="2.对象函数调用"></a>2.对象函数调用</h3><p>这个我们只需记住一点，谁调用它，this就指向谁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span>(<span class="params"></span>)  &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sayFoo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj1.<span class="title function_">sayHi</span>(); <span class="comment">//&quot;obj&quot;</span></span><br><span class="line">obj1.<span class="title function_">sayFoo</span>()(); <span class="comment">//&quot;window&quot;</span></span><br><span class="line"><span class="keyword">let</span> f = obj1.<span class="property">sayHi</span>;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">//&quot;window&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，obj1.sayHi()的输出结果，想必我们都能理解，但是f()和obj1.sayFoo()()的输出结果，可能大家就会感到很疑惑了把，为什么都是window呢，而不是obj呢，这里我们就得想起那句很重要的话了，谁调用它，this就指向谁，否则就指向window。当我们把这句话理解了，那上面的输出结果我们就会很好理解了。</p><p>在obj1.sayFoo()()这个语句中，我们可以看到，obj1调用了sayFoo()这个函数，那么为什么不输出obj呢？这里我们就得知道，sayFoo()的确是指向obj1这个对象的，但是sayFoo()这个函数会返回一个匿名函数，所以obj1.sayFoo()()这个语句就等价于了一个匿名函数f(),但是这个函数没有人调用它，所以说这里的this.name才会是window。</p><p>那么f()就和上面是一样的道理，在上述语句中，我们是将obj1.sayHi这个函数的表达式，赋值给了f，此时的f就相当于是一个新的函数，其值为function()  { console.log(this.name) },当我们执行函数f的时候，会发现没有人调用它，所以它的this指向就会指向全局window，看到这里我想对象调用这个就不会难到大家了把。</p><h3 id="3-箭头函数调用"><a href="#3-箭头函数调用" class="headerlink" title="3.箭头函数调用"></a>3.箭头函数调用</h3><p>这个我们就得注意了，箭头函数比较特殊，它是没有this指向的。箭头函数的this指向是继承外面的环境的，我们在研究它的this指向的时候，需要取往他的父级找，箭头函数的this指向它的父级的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="title class_">Ithis</span>:<span class="variable language_">this</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function">()=&gt;</span>  &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sayFoo</span>:  <span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">Ithis</span>); <span class="comment">//window对象</span></span><br><span class="line">obj1.<span class="title function_">sayHi</span>(); <span class="comment">//&quot;window&quot;</span></span><br><span class="line">obj1.<span class="title function_">sayFoo</span>()();<span class="comment">//&quot;window&quot;</span></span><br><span class="line">obj1.<span class="title function_">sayHello</span>()();<span class="comment">//&quot;obj&quot;</span></span><br></pre></td></tr></table></figure><p>上述代码中，obj1.sayHi()执行时，sayHi指向了obj1但是由于sayHI是一个箭头函数，所以它的this指向就是obj1的this指向，但是obj1的this是window对象，所以说会输出window。</p><p>对于obj1.sayFoo()()这个语句，首先sayFoo函数返回一个匿名的箭头函数，该匿名箭头函数this指向的就是sayFoo函数的this，而sayFoo也是一个箭头函数，所以它的this指向window，所以返回的匿名的箭头函数this指向window</p><p>obj1.sayHello()()，首先sayHello会返回一个匿名箭头函数，该函数指向的是sayHello的this，而sayHello函数是一个普通函数，并且obj1调用了它，所以会输出obj。</p><h3 id="4-call、apply、bind"><a href="#4-call、apply、bind" class="headerlink" title="4. call、apply、bind"></a>4. call、apply、bind</h3><p>call、apply、bind可以改变函数内部的this指向，但由于箭头函数自身没有this，所以call、apply、bind对箭头函数是不起作用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">sayFoo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;other&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj3.<span class="property">sayHi</span>.<span class="title function_">call</span>(obj4) <span class="comment">// window，call对箭头函数不起作用</span></span><br><span class="line">obj3.<span class="property">sayFoo</span>.<span class="title function_">call</span>(obj4) <span class="comment">// other，call可以改变函数内部的this到指定变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于this指向的问题，我就谈就到这里，希望对大家有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this指向问题&quot;&gt;&lt;a href=&quot;#this指向问题&quot; class=&quot;headerlink&quot; title=&quot;this指向问题&quot;&gt;&lt;/a&gt;this指向问题&lt;/h1&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;在我们研究this指向问题的时候，我们只需要知道判断th</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NodeJs入门</title>
    <link href="https://qiaimhigh.gothub.io/2022/05/30/NodeJs/"/>
    <id>https://qiaimhigh.gothub.io/2022/05/30/NodeJs/</id>
    <published>2022-05-30T09:00:39.019Z</published>
    <updated>2022-06-01T12:47:38.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="一、node-js"><a href="#一、node-js" class="headerlink" title="一、node.js"></a>一、node.js</h2><p><a href="https://nodejs.org/en/">node.js官网</a></p><p>node.js是一个基于Javascript这门语言开发出来的技术，本文我就来为大家介绍一下Node.js学习的一些基础内容。如有错误的地方欢迎大家指出错误之处。在我们了解这些基础之后，可以使用node实现一些数据库连接操作，自己写一些前后端小项目。</p><h3 id="node运行"><a href="#node运行" class="headerlink" title="node运行"></a>node运行</h3><p>在我们安装node并且编写一个js文件之后，我们便可以开始运行我们的node项目了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node 文件名.<span class="property">js</span></span><br></pre></td></tr></table></figure><h2 id="二、系统模块"><a href="#二、系统模块" class="headerlink" title="二、系统模块"></a>二、系统模块</h2><h3 id="2-1-系统模块"><a href="#2-1-系统模块" class="headerlink" title="2.1 系统模块"></a>2.1 系统模块</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node运行环境提供的API. 因为这些API都是以模块化的方式进行开发的, 所以我们又称Node运行环境提供的API为系统模块</span><br></pre></td></tr></table></figure><h3 id="2-2-fs文件系统模块"><a href="#2-2-fs文件系统模块" class="headerlink" title="2.2 fs文件系统模块"></a>2.2 fs文件系统模块</h3><h4 id="2-2-1读取、写入文件操作"><a href="#2-2-1读取、写入文件操作" class="headerlink" title="2.2.1读取、写入文件操作"></a>2.2.1读取、写入文件操作</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在我们使用node的文件系统模块之前我们需要使用require来导入该模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步读取：调用fs.requireFileSync(参数1,参数2) </span></span><br><span class="line"><span class="comment">// 参数1：读取文件的路径</span></span><br><span class="line"><span class="comment">//  参数2：读取文件时候所按照的编码格式，一般默认指定utf8</span></span><br><span class="line"><span class="comment">//该方法不接受回调函数，函数直接返回结果</span></span><br><span class="line"><span class="keyword">var</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取：调用fs.readFile(参数1[,参数2]，参数3)方法读取文件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数1：读取文件的路径</span></span><br><span class="line"><span class="comment">    参数2：读取文件时候所按照的编码格式，一般默认指定utf8</span></span><br><span class="line"><span class="comment">    参数3：回调函数，拿到读取失败和成功的结果 err dataStr</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;../files/1s.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function">(<span class="params">err,dataStr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 打印失败的结果</span></span><br><span class="line">    <span class="comment">// 如果读取成功返回null</span></span><br><span class="line">    <span class="comment">// 读取失败返回一个错误对象，dataStr 的值为undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;=====&#x27;</span>);</span><br><span class="line">    <span class="comment">// 打印成功的结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dataStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;读取文件失败!&#x27;</span>+ err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dataStr);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件模块</span></span><br><span class="line"><span class="comment">// 调用writeFile(参数1，参数2[，参数3]，参数4)函数为文件写入内容</span></span><br><span class="line"><span class="comment">// 参数1：写入文件存放的路径(如果写入的文件不存在，则系统会自动地生成相对应的文件)</span></span><br><span class="line"><span class="comment">// 参数2：表示写入的内容</span></span><br><span class="line"><span class="comment">// 参数3： 回调函数</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;../files/1.txt&#x27;</span>,<span class="string">&#x27;这是一段写入的内容&#x27;</span>,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果文件写入与成功，则err为null</span></span><br><span class="line">    <span class="comment">// 如果写入失败，则err等于一个错误对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-3-http系统模块"><a href="#2-3-http系统模块" class="headerlink" title="2.3 http系统模块"></a>2.3 http系统模块</h3><p>我们可以使用node内置模块的http模块，来创建一个web服务器，可以进行一些简单的前后端交互操作。使用http模块的基本的步骤如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基本的web服务器</span></span><br><span class="line"><span class="comment">// 1.导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 2.创建web服务器实例</span></span><br><span class="line"><span class="keyword">const</span> serve = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.绑定处request事件</span></span><br><span class="line"><span class="comment">// serve.on(&#x27;request&#x27;，处理函数（req,res）)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    当客服端请求服务端时，就会调用serve.on()函数为服务器的request事件绑定处理函数</span></span><br><span class="line"><span class="comment">    req：是请求的对象，包含了与客户端相关的数据和属性：如：  </span></span><br><span class="line"><span class="comment">        req.url ：客户端请求的URL地址，但是只会获取地址后面的后缀，如：http://127.0.0.1/user,这是req.url只会获取到 /user</span></span><br><span class="line"><span class="comment">        req.method :客户端的method请求类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    res ：响应对象，包含与服务端相关的数据和属性，如：</span></span><br><span class="line"><span class="comment">        res.end()方法的作用：向客户端发送指定的内容，并且结束这次请求的处理过程</span></span><br><span class="line"><span class="comment">        res.setHeader() 设置响应头：（设置该响应头是为了防止中文乱码）</span></span><br><span class="line"><span class="comment">            &#x27;Content-type&#x27;:&#x27;text/html;charset=utf-8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">serve.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始请求web服务&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.启动服务器</span></span><br><span class="line"><span class="comment">// serve.listen(&#x27;端口&#x27;,callback)</span></span><br><span class="line"><span class="comment">// 我们可以自己设置响应的端口号，如：8080、8088等等。当我们使用80作为我们服务器的端口号的时候，我们在访问的时候，不需要加端口号，浏览器会默认的认为是80端口访问</span></span><br><span class="line">serve.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://l27.0.0.1&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="一个简单的案例"><a href="#一个简单的案例" class="headerlink" title="一个简单的案例"></a>一个简单的案例</h5><p>响应不同的请求地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="string">&#x27;404 NOt Found&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span> || req.<span class="property">url</span> === <span class="string">&#x27;/index.html&#x27;</span>)&#123;</span><br><span class="line">        content = <span class="string">&#x27;&lt;h1&gt;index.html&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">url</span> === <span class="string">&#x27;/about.html&#x27;</span>)&#123;</span><br><span class="line">        content=  <span class="string">&#x27;&lt;h1&gt;About.html&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;text/html; utf-8;&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(content);</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Your server at http://127.0.0.1:8080&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-3-path路径模块"><a href="#2-3-path路径模块" class="headerlink" title="2.3 path路径模块"></a>2.3 path路径模块</h3><p>path 模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><p>在我们平时遇到路径拼接的操作时，都会选择使用字符串拼接的方法，但是使用这种方法的弊端有很多，如：有时候会由于我们的一些失误，导致路径出现错误的情况，而且在如果我们要将文件移植的时候，会导致移植性差。这个时候我们就可以使用path模块，来对路径做一些修改和拼接。</p><p><font color="red"><strong>今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理。不要直接使用+ 进行字符串拼接。</strong></font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path.join([...path])方法，用来将多个路径片段拼接成一个完整的路径字符串</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">paths&lt;string&gt;路径片段的序列</span></span><br><span class="line"><span class="comment">返回值&lt;string&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// path.basename(path[,ext])方法，用来从路径字符串中，将文件解析出来</span></span><br><span class="line"><span class="comment">/* path &lt;string&gt; 必选参数，表示一个路径的字符串</span></span><br><span class="line"><span class="comment">ext &lt;string&gt;  可选参数，表示文件扩展名</span></span><br><span class="line"><span class="comment">返回：&lt;string&gt; 表示路径中的最后一部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// path.extname(path)的语法格式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">path &lt;string&gt; 必选参数，表示一个路径的字符串</span></span><br><span class="line"><span class="comment">返回：&lt;string&gt; 返回得到的扩展名字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入path模块，在之后涉及到路径拼接的时候，记得使用path.join的方法，不会出现什么问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接路径</span></span><br><span class="line"><span class="comment">// path.join([..arg])</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拼接路径的时候，只有../能回退目录</span></span><br><span class="line"><span class="keyword">const</span> url = path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;/b&#x27;</span>,<span class="string">&#x27;../&#x27;</span>);</span><br><span class="line"><span class="comment">// __dirname会返回当前文件所在的目录的路径</span></span><br><span class="line"><span class="keyword">const</span> url2= path.<span class="title function_">join</span>(__dirname)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url,url2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/v/c/index.html&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(fpath)); <span class="comment">//html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fapth = __dirname + <span class="string">&#x27;/index.html&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> fullName = path.<span class="title function_">basename</span>(fapth,<span class="string">&#x27;.html&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName); <span class="comment">// index</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、require"><a href="#三、require" class="headerlink" title="三、require"></a>三、require</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    require：用来导入相关的模块</span></span><br><span class="line"><span class="comment">    1.内置模块 2.用户自定义模块 3.第三方模块 （也可以叫做 包 ，是依赖于内置模块封装出来的）</span></span><br><span class="line"><span class="comment">    其中只有用户自定义模块引入时，需要添加路径</span></span><br><span class="line"><span class="comment">    在使用require引入模块时，会自动执行模块中的代码</span></span><br><span class="line"><span class="comment">    存在模块作用域</span></span><br><span class="line"><span class="comment">    在一个模块中的，如果需要导出数据的话，需使用module.exports方法，且导出的对象以最后的module.export指向的对象为准</span></span><br><span class="line"><span class="comment">    在模块里面，exports和module.exports所指向的对象相同 export === module.exports =&gt; true</span></span><br><span class="line"><span class="comment">    切记：使用require()导入模块时，得到的永远是module.exports指向的对象，并非exports</span></span><br><span class="line"><span class="comment">    避免在同一个模块中同时使用exports 和 module.exports</span></span><br><span class="line"><span class="comment">    我们在使用require导入时，如果不添加文件的后缀名，则系统会自动的按照 js json node 的顺序逐层的向上寻找去寻找，如果都没有找到，则会报错 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">wife</span> = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h2 id="四、Express框架"><a href="#四、Express框架" class="headerlink" title="四、Express框架"></a>四、Express框架</h2><h3 id="1-1nodemon"><a href="#1-1nodemon" class="headerlink" title="1.1nodemon"></a>1.1nodemon</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodemon: 在编写Node.js项目时，如果修改项目代码，就需要频繁的重启，很繁琐，使用nodemon就可以很好的解决这个问题，它会自动的重启项目，方便我们开发和调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装nodemon : npm i -g nodemon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行:  nodemon 执行文件路径</span></span><br></pre></td></tr></table></figure><h3 id="2-1-Express"><a href="#2-1-Express" class="headerlink" title="2.1 Express"></a>2.1 Express</h3><p>Express 是一个基于 <a href="https://so.csdn.net/so/search?q=Node&spm=1001.2101.3001.7020">Node</a>平台的Web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express安装: npm i express</span><br></pre></td></tr></table></figure><h3 id="2-2-Express-框架特性"><a href="#2-2-Express-框架特性" class="headerlink" title="2.2 Express 框架特性"></a>2.2 Express 框架特性</h3><ul><li><p>提供了<strong>简洁的路由定义</strong>方式</p></li><li><p>对获取 http <strong>请求参数</strong>进行了<strong>简化处理</strong></p></li><li><p>对<strong>模板引擎支持程度高</strong>，方便渲染动态HTML页面</p></li><li><p>拥有<strong>中间件</strong>机制有效<strong>控制 HTTP 请求</strong></p></li><li><p>拥有大量第三方中间件对功能进行扩展</p></li></ul><p><img src="https://img-blog.csdnimg.cn/5b4092fea7f24c9787415284177b6fd7.png" alt="请添加图片描述"></p><p><img src="https://img-blog.csdnimg.cn/f8caa1c845d946edae6d0bf30683ad92.png" alt="请添加图片描述"></p><h3 id="2-3-express初体验"><a href="#2-3-express初体验" class="headerlink" title="2.3 express初体验"></a>2.3 express初体验</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 编写post请求方法</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 编写get请求方法</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3.中间件"></a>3.中间件</h3><h4 id="3-1-是什么中间件"><a href="#3-1-是什么中间件" class="headerlink" title="3.1 是什么中间件"></a>3.1 是什么中间件</h4><p>中间件：业务处理流程中的处理函数</p><p>中间件是一堆方法，可以接收客户端发来的请求、可以对请求作出响应，也可以将请求继续交给下一个中间件进行处理</p><p><img src="https://img-blog.csdnimg.cn/faf039941f684e0ebc337085e4243e97.png" alt="请添加图片描述"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">中间件：业务处理流程中的处理函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    全局生效的中间件：任何一个客户端请求，到达服务端都会触发的中间件。叫做全局中间件</span></span><br><span class="line"><span class="comment">    通过调用app.use(中间函数)，即可定义一个全局生效的中间件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    局部生效的中间件：不使用app.use()定义的中间件,都叫做局部中间件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    中间件作用：多个中间件之间共享的是同一份req和res.所以我们可以在上游的中间件中，统一</span></span><br><span class="line"><span class="comment">        为req和res对象添加自定义属性或方法，供下游的中间件或路由进行使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    定义多个全局中间件：可以使用app.use()连续定义多个中间件，系统会按照定义的顺序</span></span><br><span class="line"><span class="comment">        进行执行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    中间件使用注意事项：</span></span><br><span class="line"><span class="comment">        1.一定要将中间件放置在路由之前</span></span><br><span class="line"><span class="comment">        2.客户端发送的请求，可以连续调用多个中间件</span></span><br><span class="line"><span class="comment">        3.不要忘记在中间件函数里面写next()函数</span></span><br><span class="line"><span class="comment">        4.为了防止代码逻辑混乱，调用next()函数后不要写额外的代码</span></span><br><span class="line"><span class="comment">        5.连续调用多个中间件，多个中间件之间，共享req 和 res对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    中间件的分类：</span></span><br><span class="line"><span class="comment">        1.应用级别：绑定到app实例上的中间件，如app.use()、app.get()</span></span><br><span class="line"><span class="comment">        2.路由级别：绑定到路由上的中间件</span></span><br><span class="line"><span class="comment">        3.错误级别：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</span></span><br><span class="line"><span class="comment">                app.use(function(err,req,res,next)&#123;</span></span><br><span class="line"><span class="comment">                    console.log(&#x27;发生错误&#x27; + err.message);</span></span><br><span class="line"><span class="comment">                    res.send(&#x27;Error! + err.message)</span></span><br><span class="line"><span class="comment">                &#125;)</span></span><br><span class="line"><span class="comment">                特殊：必须注册在所有路由之后</span></span><br><span class="line"><span class="comment">        4.Express内置：express.static :没有兼容性</span></span><br><span class="line"><span class="comment">                      express.json 解析JSON格式（有兼容性，仅在4.16.0+版本中使用）</span></span><br><span class="line"><span class="comment">                      express.urlencoded 解析URL-encoded格式的请求数据（有兼容性，仅在4.16.0+版本中使用）</span></span><br><span class="line"><span class="comment">        5.第三方    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">// 定义一个简单的中间件函数</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> mw = <span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    req.<span class="property">startTime</span> = time;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一个简单的中间件函数&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mw2 = <span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    req.<span class="property">startTime</span> = time;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一个简单的中间件函数&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局中间件</span></span><br><span class="line"><span class="comment">// app.use(mw)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部生效的中间件(同时使用多个局部中间件，或者使用数组将中间件包起来，然后调用)</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,mw,mw2,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Index.html&#x27;</span> + (<span class="title class_">Date</span>.<span class="title function_">now</span>() - req.<span class="property">startTime</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;没中间件&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/error&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;服务器内部发生错误！！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误级别中间件，捕获整个项目的异常错误，从而防止程序崩溃</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err,req,res,next</span>)&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;服务器错误&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;https://127.0.0.1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h4 id="3-2-中间件的应用"><a href="#3-2-中间件的应用" class="headerlink" title="3.2 中间件的应用"></a>3.2 中间件的应用</h4><p>1.路由保护：<br>客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 express 框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为客户端访问 /user 请求时候的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用户没有登录</span></span><br><span class="line">    <span class="keyword">let</span> isLogin = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果用户登录</span></span><br><span class="line">    <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;用户已经登录&quot;</span>)</span><br><span class="line">        <span class="comment">// 让请求继续向下执行</span></span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;用户未登录&quot;</span>)</span><br><span class="line">        <span class="comment">// 如果用户没有登录，直接对客户端作出响应</span></span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;您还没有登录，无法访问当前页面&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;您已登录 可以访问当前页面&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/admin&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&quot;不受中间件约束&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网站服务器启动成功&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7e1b18c675874e208ea942521ac87c6c.png" alt="请添加图片描述"></p><p><img src="https://img-blog.csdnimg.cn/406d912f8d1548349edb2e7b8eb6d467.png" alt="请添加图片描述"></p><p><img src="https://img-blog.csdnimg.cn/ac0ddc8955da408ba30833ea63e18f73.png" alt="请添加图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e4b23ce78253451e8eff80818ed705ef.png" alt="请添加图片描述"></p><p>2.网站维护公告<br>在所有路由最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 express 框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 此处不设置next()函数，阻止用户访问网站</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;当前网站正在维护...&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将不会被访问</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;您已登录 可以访问当前页面&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.自定义404页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 express 框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 为客户端响应404状态码以及提示信息</span></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">send</span>(<span class="string">&#x27;当前访问的页面是不存在的&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;http://127.0.0.1&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/16e4d0811d4b464587d8fdc2e7c4db4c.png" alt="请添加图片描述"></p><p><img src="https://img-blog.csdnimg.cn/9481a153d32e48a9b54efff211a7831b.png" alt="请添加图片描述"></p><h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用res.send()方法向客户端发送数据</span></span><br><span class="line"><span class="comment">// 使用req.query属性,可以访问到客户端通过查询字符串的形式，发送到服务器的参数</span></span><br><span class="line"><span class="comment">// 使用req.params对象，可以访问到URL中，通过:匹配到的动态参数</span></span><br><span class="line"><span class="comment">/* 使用req的data事件，来获取客户端发送到服务器的数据：如果客户端返回的数据比较多的话，客户端会将数据分割成好几部分，则data事件会触发多次，</span></span><br><span class="line"><span class="comment">        没触发一次就会获取一些数据，我们需要对这些数据进行拼接</span></span><br><span class="line"><span class="comment">    req的end事件：当客户端所有的数据发送完毕之后，会触发end事件</span></span><br></pre></td></tr></table></figure><h2 id="4-express路由"><a href="#4-express路由" class="headerlink" title="4.express路由"></a>4.express路由</h2><h4 id="4-1路由"><a href="#4-1路由" class="headerlink" title="4.1路由"></a>4.1路由</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由：就是一种映射关系</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    路由的组成：三部分 请求类型、请求地址、处理函数</span></span><br><span class="line"><span class="comment">    app.METHOD(PATH,HANDLER)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    路由匹配过程：每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才调用对应的处理函数</span></span><br><span class="line"><span class="comment">        注意：按照定义的先后顺序进行匹配；请求类型和请求的URL同时匹配成功，才会调用对应的处理函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用：</span></span><br><span class="line"><span class="comment">    1.简单的使用：(缺点随着路由的增多，代码量会增加)</span></span><br><span class="line"><span class="comment">        引入调用：const express = require(express)</span></span><br><span class="line"><span class="comment">                const app = express();</span></span><br><span class="line"><span class="comment">        挂载路由：</span></span><br><span class="line"><span class="comment">                app.get(地址，(req,res)=&gt;&#123;&#125;)</span></span><br><span class="line"><span class="comment">        启动服务器：</span></span><br><span class="line"><span class="comment">                app.listen(启动端口,()=&gt;&#123;&#125;)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    2.模块化路由（推荐使用）</span></span><br><span class="line"><span class="comment">        创建路由模块对应的.js文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        调用express.Router()函数创建路由对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        想路由对象上挂载具体的路由</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用module.exports向外共享路由</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用app.use()函数注册路由模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// express路由.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;GET&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br><span class="line"></span><br><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./express路由&#x27;</span>)</span><br><span class="line"><span class="comment">// app.use()是用来注册全局中间件的</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-GET请求参数的获取"><a href="#4-2-GET请求参数的获取" class="headerlink" title="4.2 GET请求参数的获取"></a>4.2 GET请求参数的获取</h4><p>Express 框架中使用 <code>req.query</code> 即可 <code>获取GET参数</code> ，框架内部会将GET参数转换为<code>对象</code>并返回。</p><p><img src="https://img-blog.csdnimg.cn/20201026200837974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NTc1OTI1,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 express 框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建Web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/index&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// req.query 获取请求参数</span></span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">query</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c78d0d74218b488097041fa39fb9066b.png" alt="请添加图片描述"></p><h4 id="4-3POST参数"><a href="#4-3POST参数" class="headerlink" title="4.3POST参数"></a>4.3POST参数</h4><h5 id="Express-中接收-POST请求参数"><a href="#Express-中接收-POST请求参数" class="headerlink" title="Express 中接收 POST请求参数"></a>Express 中接收 <code>POST请求参数</code></h5><p><em>在服务器，可以使用req.body这个属性来获取客户端发送过来的请求体数据</em>,默认情况下，<em>如果不配置解析表单的中间件，则req.body 默认等于 undefined</em></p><p>方法一：需要借助第三方包 <code>body-parser</code></p><p><img src="https://img-blog.csdnimg.cn/20201026202544835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NTc1OTI1,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装body-<span class="attr">parser</span>: npm i body-parser</span><br></pre></td></tr></table></figure><p>body-parser文档地址：<a href="http://www.expressjs.com.cn/en/resources/middleware/body-parser.html">http://www.expressjs.com.cn/en/resources/middleware/body-parser.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 express 框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建Web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>)</span><br><span class="line"><span class="comment">//配置body-parser</span></span><br><span class="line"><span class="comment">//只要加入这个配置，则在req请求对象上多出来一个属性：body；</span></span><br><span class="line"><span class="comment">//也就是说你就可以直接通过req.body来获取表单POST请求体数据了；</span></span><br><span class="line"><span class="comment">// 拦截所有请求</span></span><br><span class="line"><span class="comment">// extended: false  方法内部使用 querystring 模块处理请求参数的格式</span></span><br><span class="line"><span class="comment">// extended: true   方法内部使用第三方模块 qs 来处理请求参数的格式</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/index&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// req.query 获取请求参数</span></span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">body</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f1447aa5f08a49e8bd6450c5ef945398.png" alt="请添加图片描述"></p><p>方法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置解析表单数据的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;)) <span class="comment">// 解析application/x-www-form-urlencoded格式的表单数据</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())  <span class="comment">// 解析json格式的表单数据</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;headerlink&quot; title=&quot;Node.js&quot;&gt;&lt;/a&gt;Node.js&lt;/h1&gt;&lt;h2 id=&quot;一、node-js&quot;&gt;&lt;a href=&quot;#一、node-js&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CORS解决跨域问题</title>
    <link href="https://qiaimhigh.gothub.io/2022/05/29/cors/"/>
    <id>https://qiaimhigh.gothub.io/2022/05/29/cors/</id>
    <published>2022-05-29T08:49:00.694Z</published>
    <updated>2022-06-01T12:47:22.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cors解决跨域"><a href="#Cors解决跨域" class="headerlink" title="Cors解决跨域"></a>Cors解决跨域</h1><h2 id="一、为什么会出现跨域"><a href="#一、为什么会出现跨域" class="headerlink" title="一、为什么会出现跨域"></a>一、为什么会出现跨域</h2><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h2 id="二、什么是跨域"><a href="#二、什么是跨域" class="headerlink" title="二、什么是跨域"></a>二、什么是跨域</h2><p>当一个请求的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><table><thead><tr><th align="center">当前页面url</th><th>被请求页面url</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td align="center"><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td><td>否</td><td>同源（协议、域名、端口号相同）</td></tr><tr><td align="center"><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td><td>跨域</td><td>协议不同</td></tr><tr><td align="center"><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.baidu.com/">http://www.baidu.com/</a></td><td>跨域</td><td>主域名不同</td></tr><tr><td align="center"><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://blog.test.com/">http://blog.test.com/</a></td><td>跨域</td><td>子域名不同</td></tr><tr><td align="center"><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.test.com:8080/">http://www.test.com:8080/</a></td><td>跨域</td><td>端口号不同</td></tr></tbody></table><h2 id="三、非同源限制"><a href="#三、非同源限制" class="headerlink" title="三、非同源限制"></a>三、非同源限制</h2><ul><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 AJAX 请求</li></ul><h2 id="四、解决办法"><a href="#四、解决办法" class="headerlink" title="四、解决办法"></a>四、解决办法</h2><h3 id="1、CORS"><a href="#1、CORS" class="headerlink" title="1、CORS"></a>1、CORS</h3><p>CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>浏览器将CORS跨域请求分为简单请求和非简单请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">简单请求:(需同时满足以下两点)</span><br><span class="line">                1.请求的方式只能是GET,POST,HEAD</span><br><span class="line">                2.HTTP请求头是：</span><br><span class="line">                    Accept</span><br><span class="line">                    Accept-Language</span><br><span class="line">                    Content-Language</span><br><span class="line">                    Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br><span class="line">不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</span><br><span class="line"></span><br><span class="line">非简单请求:(满足任意一点)</span><br><span class="line">                1.请求方式为除GET,POST,HEAD之外的Method类型</span><br><span class="line">                2.请求头包含自定义头端</span><br><span class="line">                3.向服务器发送了application/json格式的数据  </span><br><span class="line">   非简单请求在请求CROS时，会在正式通信之前，增加一次HTTP查询请求，称为预检请求。</span><br><span class="line">简单、非简单请求的区别:简单请求之发送一次请求,预检请求发送两次请求,在发送之前会先发送一次OPTION的与请求,与请求成功之后才会发送实际的请求和数据 </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.CORS主要是在服务端进行配置，客户端浏览器无需做任何配置，即可请求开启了CORS的接口</span><br><span class="line"></span><br><span class="line">2.CORS在浏览器中有兼容性</span><br><span class="line"></span><br><span class="line">3.CORS默认情况下只支持GET、POST、HEAD，如果客户端希望通过PUT\DELETE等方式请求服务器资源,则须通过Access-Control-Allow-Methods来指明实际请求所允许的HTTP方法</span><br><span class="line">res.setHEader(&#x27;Access-Control-Allow- Methods&#x27;,&#x27;POST,GET,DELETE,HEAD&#x27;)</span><br><span class="line">或者</span><br><span class="line">res.setHEader(&#x27;Access-Control-Allow-Methods&#x27;,*)</span><br></pre></td></tr></table></figure><h4 id="前端解决"><a href="#前端解决" class="headerlink" title="前端解决"></a>前端解决</h4><ol><li><p>原生Ajax（需和后端一起使用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>jQuery Ajax</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="attr">xhrFields</span>: &#123;</span><br><span class="line">       <span class="attr">withCredentials</span>: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">crossDomain</span>: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-vue框架"><a href="#3-vue框架" class="headerlink" title="3.vue框架"></a>3.vue框架</h4><p>a.) axios设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>b.) vue-resource设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">http</span>.<span class="property">options</span>.<span class="property">credentials</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="服务端解决"><a href="#服务端解决" class="headerlink" title="服务端解决"></a>服务端解决</h4><ol><li><p>Nodejs（Express，前端无需设置任何东西即可解决）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CORS（主流方案）:cors是express提供的第三方库，通过安装和配置cors中间件，可以很方便的解决跨域问题</span></span><br><span class="line"><span class="comment">            由一系列HTTP的响应头组成，这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">1.安装： npm i cors</span></span><br><span class="line"><span class="comment">    2.导入中间件 const cors = require(&quot;cors&quot;)</span></span><br><span class="line"><span class="comment">3. 配置中间件 app.use(&quot;cors()&quot;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 配置cros跨域请求中间件</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = <span class="built_in">require</span>(<span class="string">&#x27;./api&#x27;</span>)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/jsonp&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fuName = req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="attr">name</span>:<span class="string">&#x27;黎明&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> str =  <span class="string">`<span class="subst">$&#123;fuName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span></span><br><span class="line">    res.<span class="title function_">send</span>(str)</span><br><span class="line">&#125;) </span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>,api)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Error&#x27;</span>+err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://localhost&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="原生Node（需和前端一起使用）"><a href="#原生Node（需和前端一起使用）" class="headerlink" title="原生Node（需和前端一起使用）"></a>原生Node（需和前端一起使用）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.<span class="title function_">addListener</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.<span class="title function_">addListener</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        postData = qs.<span class="title function_">parse</span>(postData);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://www.domain1.com&#x27;</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(postData));</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><p><a href="https://segmentfault.com/a/1190000011145364">跨域解决参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cors解决跨域&quot;&gt;&lt;a href=&quot;#Cors解决跨域&quot; class=&quot;headerlink&quot; title=&quot;Cors解决跨域&quot;&gt;&lt;/a&gt;Cors解决跨域&lt;/h1&gt;&lt;h2 id=&quot;一、为什么会出现跨域&quot;&gt;&lt;a href=&quot;#一、为什么会出现跨域&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue3.0注意事项</title>
    <link href="https://qiaimhigh.gothub.io/2022/05/29/vue/"/>
    <id>https://qiaimhigh.gothub.io/2022/05/29/vue/</id>
    <published>2022-05-29T06:02:21.099Z</published>
    <updated>2022-06-01T12:48:09.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue3-0-setup里没有this-没有this-没有this"><a href="#vue3-0-setup里没有this-没有this-没有this" class="headerlink" title="vue3.0  setup里没有this,没有this,没有this."></a><a href="https://so.csdn.net/so/search?q=vue3.0&spm=1001.2101.3001.7020">vue3.0</a>  setup里没有this,没有this,没有this.</h1><h3 id="vue—message消息提示"><a href="#vue—message消息提示" class="headerlink" title="vue—message消息提示"></a><a href="https://www.cnblogs.com/Bluebells/p/15146567.html">vue—message消息提示</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$message(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>/<span class="string">&#x27;warning&#x27;</span>/<span class="string">&#x27;error&#x27;</span>/<span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;消息提示内容&#x27;</span>,</span><br><span class="line">    <span class="attr">showClose</span>: <span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">duration</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">center</span>: <span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">dangerouslyUseHtmlString</span>: <span class="literal">true</span>/<span class="literal">false</span>      </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>type：定义消息提示框的不同状态，默认为info</p><p>message：消息提示内容</p><p>showClose：默认的message是不可以手动关闭的，如果需要手动关闭，设置showClose为true，一般与duration搭配使用</p><p>duration：显示时间, 毫秒。设为 0 则不会自动关闭，默认3000ms</p><p>center：是否居中</p><p>dangerouslyUseHTMLString：将此属性设置为true，message会被当成html片段处理</p><p><img src="https://img2020.cnblogs.com/blog/2246812/202108/2246812-20210816103718643-1049861583.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue3-0-setup里没有this-没有this-没有this&quot;&gt;&lt;a href=&quot;#vue3-0-setup里没有this-没有this-没有this&quot; class=&quot;headerlink&quot; title=&quot;vue3.0  setup里没有this,没有thi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://qiaimhigh.gothub.io/2022/05/29/hello-world/"/>
    <id>https://qiaimhigh.gothub.io/2022/05/29/hello-world/</id>
    <published>2022-05-29T05:35:53.111Z</published>
    <updated>2022-05-29T05:35:53.111Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
